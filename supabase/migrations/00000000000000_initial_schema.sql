-- Enable Row Level Security
ALTER SYSTEM SET max_locks_per_transaction = 100;

-- Create a custom type for user roles
CREATE TYPE public.user_role AS ENUM ('user', 'admin');

-- Create a table for user profiles
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE,
  username TEXT UNIQUE NOT NULL,
  full_name TEXT,
  avatar_url TEXT,
  role public.user_role DEFAULT 'user'::public.user_role,
  preferences JSONB DEFAULT '{"language": "en", "theme": "dark"}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (id)
);

-- Create a table for movies
CREATE TABLE public.movies (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT,
  release_year INTEGER,
  duration_minutes INTEGER,
  poster_url TEXT,
  backdrop_url TEXT,
  imdb_rating FLOAT,
  tmdb_id TEXT UNIQUE,
  watchmode_id TEXT UNIQUE,
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a table for genres
CREATE TABLE public.genres (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  description TEXT
);

-- Create a table for movie genres (many-to-many relationship)
CREATE TABLE public.movie_genres (
  movie_id BIGINT REFERENCES public.movies(id) ON DELETE CASCADE,
  genre_id INTEGER REFERENCES public.genres(id) ON DELETE CASCADE,
  PRIMARY KEY (movie_id, genre_id)
);

-- Create a table for user movie ratings
CREATE TABLE public.user_movie_ratings (
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  movie_id BIGINT REFERENCES public.movies(id) ON DELETE CASCADE,
  rating SMALLINT NOT NULL CHECK (rating >= 1 AND rating <= 5),
  review TEXT,
  watched_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, movie_id)
);

-- Create a table for user watchlist
CREATE TABLE public.user_watchlist (
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  movie_id BIGINT REFERENCES public.movies(id) ON DELETE CASCADE,
  added_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (user_id, movie_id)
);

-- Create a table for movie recommendations
CREATE TABLE public.movie_recommendations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  movie_id BIGINT REFERENCES public.movies(id) ON DELETE CASCADE,
  reason TEXT,
  score FLOAT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a function to update the updated_at column
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers to update updated_at columns
CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_movies_updated_at
BEFORE UPDATE ON public.movies
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_ratings_updated_at
BEFORE UPDATE ON public.user_movie_ratings
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Create a function to handle new user signups
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'username',
    COALESCE(NEW.raw_user_meta_data->>'full_name', split_part(NEW.email, '@', 1)),
    NEW.raw_user_meta_data->>'avatar_url'
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a trigger to handle new user signups
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Set up Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.movies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.movie_genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_movie_ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_watchlist ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.movie_recommendations ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
-- Profiles
CREATE POLICY "Users can view all profiles"
  ON public.profiles FOR SELECT
  USING (true);

CREATE POLICY "Users can update their own profile"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id);

-- Movies
CREATE POLICY "Enable read access for all users"
  ON public.movies FOR SELECT
  USING (true);

CREATE POLICY "Enable insert for authenticated users only"
  ON public.movies FOR INSERT
  WITH CHECK (auth.role() = 'authenticated');

-- User Movie Ratings
CREATE POLICY "Users can view all ratings"
  ON public.user_movie_ratings FOR SELECT
  USING (true);

CREATE POLICY "Users can manage their own ratings"
  ON public.user_movie_ratings
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- User Watchlist
CREATE POLICY "Users can view their own watchlist"
  ON public.user_watchlist FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own watchlist"
  ON public.user_watchlist
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Create a function to search movies
CREATE OR REPLACE FUNCTION public.search_movies(query TEXT)
RETURNS SETOF public.movies AS $$
  SELECT *
  FROM public.movies
  WHERE
    to_tsvector('english', title) @@ websearch_to_tsquery('english', query) OR
    to_tsvector('english', description) @@ websearch_to_tsquery('english', query)
  ORDER BY
    ts_rank(to_tsvector('english', title), websearch_to_tsquery('english', query)) * 2 +
    ts_rank(to_tsvector('english', description), websearch_to_tsquery('english', query))
  DESC;
$$ LANGUAGE sql STABLE;

-- Create a function to get movie recommendations
CREATE OR REPLACE FUNCTION public.get_movie_recommendations(
  user_id UUID,
  limit_count INTEGER DEFAULT 10
)
RETURNS TABLE (
  movie_id BIGINT,
  title TEXT,
  poster_url TEXT,
  match_score FLOAT,
  reason TEXT
) AS $$
BEGIN
  RETURN QUERY
  WITH user_ratings AS (
    SELECT movie_id, rating
    FROM public.user_movie_ratings
    WHERE user_id = $1
  ),
  user_preferences AS (
    SELECT 
      g.id AS genre_id,
      g.name AS genre_name,
      COALESCE(AVG(ur.rating), 0) AS avg_rating,
      COUNT(ur.*) AS rating_count
    FROM public.genres g
    LEFT JOIN public.movie_genres mg ON g.id = mg.genre_id
    LEFT JOIN user_ratings ur ON mg.movie_id = ur.movie_id
    GROUP BY g.id, g.name
    ORDER BY avg_rating DESC, rating_count DESC
    LIMIT 3
  ),
  recommended_movies AS (
    SELECT 
      m.id,
      m.title,
      m.poster_url,
      (
        -- Score based on genre match
        SELECT COUNT(*) * 2.0
        FROM public.movie_genres mg
        WHERE mg.movie_id = m.id
        AND mg.genre_id IN (SELECT genre_id FROM user_preferences)
      ) + 
      (
        -- Score based on average rating
        COALESCE((SELECT AVG(rating) FROM public.user_movie_ratings WHERE movie_id = m.id), 0) * 0.5
      ) AS match_score,
      (
        SELECT string_agg(up.genre_name, ', ')
        FROM user_preferences up
        JOIN public.movie_genres mg ON up.genre_id = mg.genre_id
        WHERE mg.movie_id = m.id
      ) AS reason
    FROM public.movies m
    WHERE m.id NOT IN (SELECT movie_id FROM user_ratings)
    ORDER BY match_score DESC
    LIMIT $2
  )
  SELECT 
    rm.id::BIGINT,
    rm.title,
    rm.poster_url,
    rm.match_score,
    'Recommended based on your preferences in: ' || COALESCE(rm.reason, 'popular movies') AS reason
  FROM recommended_movies rm
  ORDER BY rm.match_score DESC;
END;
$$ LANGUAGE plpgsql STABLE;
